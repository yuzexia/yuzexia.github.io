---
title: 函数表达式
date: 2017-05-09 14:31:41
tags: [javascript]
---

## 函数表达式

1. 函数声明
> 函数声明语法

```javascript
function funName(){
    //函数体
}
```
function是关键字，然后是函数名字，还有一个非标准的name属性，通过这个属性可以访问到函数指定的名字。这个属性的值永远等于跟在function关键字后面的标识符。
```javascript
console.log(funName.name); //funName可以使用arguments.callee自调用

```
<!-- more -->
> 重要的特性

函数声明提升(function declaration hoisting)，意思是在执行代码时会先读取函数声明，
意味着，**可以把函数声明放在调用它的语句后面**

```javascript
abc();  //"1"
function abc(){
    console.log('1');
}
```
上述代码能够正常执行

2. 函数表达式

> 函数声明的几种形式
- 最常见的一种形式
```javascript
var funcName = function(){
    //函数体
}
```

创建一个函数并将它赋值给变量funcName。这种情况下创建的函数为**匿名函数(anonymous function)**，因为function后面没有标识符。
> 匿名函数有时候也叫拉姆达函数，匿名函数的name属性是空字符串。

函数表达式与其他表达式一样，在使用前必须先赋值，要不能会报错。
```javascript
abc();
var abc = function(){
    console.log("1");
}
//报错：Uncaught TypeError: abc is not a function
```

理解函数提升的关键，就是理解函数声明与函数表达式之间的区别：
> 思考题
```javascript
//不要这么做
if(isOk){
    function sayHello(){
        console.log('hello');
    }
}else{
    function sayHello(){
        console.log('world');
    }
}
```
结果是什么？
> 从表面上看，上述代码表示在isOk为true时，使用一个sayHello()的定义，否则，使用另一个sayHello()的定义    
实际上，在ECMAScript中属于无效语法，javascript引擎会尝试修正错误，将其转换为合理的状态。    
但是问题是各个浏览器尝试修正错误的做法并不一致。大多数浏览器会返回第一个声明，    
因此使用这种方式很危险

使用函数表达式就不会有这种问题
```javascript
//可以这样做
var sayHello;
if(isOk){
    sayHello = function(){
        alert('hello');
    }
}else{
    sayHello = function(){
        alert('world!');
    }
}
```
能够创建函数再赋值给变量，也就能够把函数作为其他函数的返回值。


#### 7.1 递归
> 递归函数是在一个函数通过名字调用自身的情况下构成的

```javascript
function count(num){
    if(num <= 1){
        return 1;
    }else{
        return num * count(num-1);
    }
}
```
> 上述代码是经典的阶乘函数    
虽然这个函数从表面上看来没什么问题，但下面的代码却可能导致它出错

```javascript
var anotherCount = count;
count = null;
alert(anotherCount(4))  // 报错:count is not a function
```
>上面代码，先把函数count()保存在变量anotherCount中，然后将count变量设置为null，结果指向原始函数的引用只剩下一个。    
但是在调用anotherCount()时，需要执行count()，而count已经不在是一个函数，所以导致出错"count is not a function"

> 在这种情况下，使用arguments.callee可以解决这个问题    
arguments.callee是一个指向正在执行的函数的指针，因此可以用它来实现函数的递归调用

```javascript
function count(num){
    if(num <= 1){
        return 1;
    }else{
        return num * arguments.callee(num-1);
    }
}
```

通过使用`arguments.callee`代替函数名，可以确保无论怎么样调用函数都不会出问题，    
因此，在编写函数递归调用时，使用`arguments.callee`总比使用函数名更保险。

> 不过在严格模式下，"严格模式"（strict mode）不能通过脚本访问`arguments.callee`，访问这个属性将会报错。    
不过可以使用命名函数表达式来达成相同的结果。

```javascript
'strict mode'   //严格模式
var count = (function f(num){
    if(num <= 1){
        return 1;
    }else{
        return num * f(num-1);
    }
});
```
>以上代码创建一个名为f()的命名函数表达式，然后将它赋值给变量count。即便是函数赋值给另一个变量   
函数的名字f仍让有效，所以递归调用照样能正常完成。这种方式在严格模式和非严格模式都行的通。

#### 7.2 闭包
###### 概念
> 闭包是指有权访问另一个函数作用域中的变量的函数
创建闭包最常见的方式，就是在一个函数内部创建另一个函数。

为什么还能够访问内部变量？
>  是因为内部函数的作用域中包含父函数的作用域。

###### 作用域链
> 当某个函数被调用时，会创建一个执行环境（execution context）及相应的作用域链接。   
-->   
然后使用arguments和其他命名参数的值来初始化函数的活动对象（activation object）。   
-->   
但在作用域链中，外部函数的活动对象始终处于第二位，外部函数的外部函数的活动对象处于第三位，...     
直至作为作用域链终点的全局执行环境。   

> 在函数执行过程中，为读取和写入变量的值，就需要在作用域链中查找变量。
```javascript
function compare(value1, value2){
    if(value1 < value2){
        return -1;
    } else if(value1 > value2){
        return 1;
    } else {
        return 0;
    }
}
```
上述代码：
1. 定义compare()函数
2. 在全局作用域中调用它
3. 当调用compare()时，会创建一个包含arguments,value1,value2的活动对象
4. 全局执行环境的变量对象（包括result和compare）在compare()执行的作用域链中处于第二位。


compare()函数执行时的作用域链关系图

![图片](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1489995952212&di=de4fccb3e1965772e5ac835604c69019&imgtype=0&src=http%3A%2F%2Fimages2015.cnblogs.com%2Fblog%2F740839%2F201509%2F740839-20150914151133867-323877975.jpg)

后台每个执行环境都有一个表示变量的对象----**变量对象**。   
**全局环境**的变量对象始终存在，而像`compare()`函数这样的**局部环境**的变量对象   
则只在*函数执行*的过程中存在。

- 在创建`compare()`函数时，会创建一个预先包含全局变量对象的作用域链，这个作用域链被保存在内部的`[[Scope]]`属性中
- 当调用`compare()`函数时，会为函数创建一个*执行环境*，然后通过复制函数的`[[Scope]]`属性中的对象构建起执行环境的作用域链接。
- 此后，又有一个活动对象（在此作为变量对象使用）被创建并推入执行环境作用域链的前端

> 对于上述例子而言，compare()函数的执行环境，其作用域链中包含两个变量：
1. 本地变量对象
2. 全局变量对象
> 作用域链*本质上*是一个指向*变量对象*的*指针列表*，它只包含**引用**但不实际包含**对象**。

在函数中访问一个变量时，就会从作用域链中搜索具有相应名字的变量。   
一般来讲，当函数执行完毕后，局部活动对象机会被销毁，内存中仅保存全局作用域（全局执行环境的变量对象）   
但是，***闭包***的情况又有所不同。

在另一个函数内部定义的函数会将包含函数(即外部函数)的活动对象添加到它的作用域链中。在匿名函数从createComparisonFunction()中被返回后，它的作用域链被初始化为包含createComparisonFunction()函数的活动对象和全局变量对象。这样匿名函数就可以访问在createComparisonFunction()中定义的所有变量。更为重要的是createComparisonFunction()函数在执行完毕后，其活动对象也不会被销毁，因为匿名函数的作用域链仍然在引用这个活动对象。换句话说，当createComparisonFunction()函数返回后，其执行环境的作用域链会被销毁，但它的活动对象仍然留在内存中；直到匿名函数被销毁后，createComparisonFunction()的活动对象才被销毁

> [注意]由于闭包会携带包含它的函数的作用域链，因此会比其他函数占用更多的内存。过度使用闭包可能会导致内存占用过多，所以只在绝对必要时使用闭包。

```javascript
//创建函数
var compareNames = createComparisonFunction("name");
//调用函数
var result = compareNames({name:"Nicholas"},{name:"Greg"});
//解除对匿名函数的引用(以便释放内存)
compareNames = null;
/*首先，创建的比较函数被保存在变量compareNames中，
而通过将compareNames设置为等于null，解除该函数的引用，
就等于通知垃圾回收例程将其清除。随着匿名函数的作用域链被销毁，
其他作用域(除了全局作用域)也都安全地销毁了。*/
```

![](http://images2015.cnblogs.com/blog/740839/201509/740839-20150914151358039-898068634.jpg)

> 由于闭包会携带包含它的函数的作用域，因此会比其他函数占用更多的内存。   
过度使用闭包可能会导致内存占用过多，   
V8 javascript引擎会尝试回收被闭包占用的内存。

##### 7.2.1 闭包和变量
> 作用域链的这种配置机制引起了一个值得注意的副作用，即闭包只能取得包含函数中任何变量的最后一个值。    

闭包保存的是**整个变量对象**，而不是**某个特殊的值**。

```javascript
function createFunctions (){
    var result = new Array();
    
    for (var i=0;i<10;i++){
        result[i] = function(){
            return i;
        };
    }
    return result;
}
```
这个函数会返回一个值。结果是每个函数都返回10.   
因为每个函数的作用域中都保存着createFunctions()函数的活动对象，
所以他们引用的都是同一个变量i。
当createFunctions()函数返回后，变量i的值是10，此时每个函数都引用着保存变量i
的同一个变量对象，
所以每个函数内部i的值都是10。

![闭包](http://images.cnblogs.com/cnblogs_com/White-Quality/969463/o_%e5%be%ae%e4%bf%a1%e6%88%aa%e5%9b%be_20170321125523.png)
```
Scopes[2]
Closure (createFunctions)
i:10
```
我们可以通过创建另一个匿名函数强制让闭包的行为符合预期

```
function createFunctions(){
    var result = new Array();
    
    for(var i = 0;i < 10; i++){
        result[i] = function(num){
           return function(){
               return num;
           } 
        }(i)
    }
    return result;
}
```
![closure-2](http://images.cnblogs.com/cnblogs_com/White-Quality/969463/o_closure.png)

改写后的createFunctions()函数，每个函数都会返回不同的索引值了。
没有直接把闭包赋值给数组，而是定义了一个匿名函数，并将立即执行该匿名函数的结果赋值给数组。
这里的匿名函数有一个参数num，也就是最终要返回的值。
在调用每个匿名函数时，我们出入变量i。
由于函数参数是按值传递的，所以就会将变量i的当前值赋值给参数num。
而在这个匿名函数内部，又创建了一个访问num的闭包，
这样一来，result数组中的每个函数都有自己num变量的副本，
因此就可以返回各自不同的数值了。

##### 7.2.2关于this对象
> this对象是在运行时基于函数的执行环境绑定的：   
在全局函数中：thiis等于window；
而在函数被当做某个对象的方法调用时：this等于那个对象。   
不过匿名函数的执行环境具有全局性，因此匿名函数的this对象通常也指向window；   
在通过call()和apply()改变函数执行环境的情况下，this就会指向其他对象。

```
var name = "the window";
var object = {
  name:"my object",
  getNameFunc:function(){
    return function(){
        return this.name
    }
  }
};

object.getNameFunc()();   //"the window"
```
为什么匿名函数没有取得其包含作用域（或外部作用域）的this对象呢？

> 前面提到过，每个函数再被调用的时候会自动取得两个特殊变量 `this` 和 `arguments`。内部函数再搜索这两个变量时，只会搜索到其活动对象为止，因此永远不可能直接访问外部函数中的这两个变量(详见下图)。

![](http://images2015.cnblogs.com/blog/740839/201509/740839-20150914151358039-898068634.jpg)

不过，把外部函数作用域中的this对象保存在一个闭包能够访问到的变量里面，就可以让闭包访问该对象了。
```
var name = "the window";
var object = {
  name:"my object",
  getNameFunc:function(){
    var that = this;
    return function(){
        return that.name
    }
  }
};

object.getNameFunc()();   //"my object"
```
> tips: `this` 和 `arguments`也存在同样的问题，如果想访问作用域中的arguments对象，必须将对该对象的引用保存到另一个闭包能够访问的变量中。

在几种特殊情况下，this的值可能会意外地改变
```
var name = "the window";
var object = {
  name:"my object",
  getNameFunc:function(){
    return this.name
  }
};

object.getNameFunc();  //'my object'
(object.getNameFunc)();  //'my object'
(object.getNameFunc = object.getNameFunc)(); //'the window'
```
> 上述代码：第一种方式跟平常一样调用了`object.getNameFunc()`,返回`my object`,因为`this.name`就是`object.name`。   
第二种方式在调用这个方法前添加了括号，虽然添加了括号，就好像只是在引用一个函数，但this的值得到了维持，因为`object.getNameFunc`和`object.getNameFunc`定义是相同的。    
第三种方式：先执行了一条赋值语句，然后在调用赋值后的结果。因为这个赋值表达式的值是函数本身，所以this的值得不到维持，结果返回`the window`。
